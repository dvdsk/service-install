use std::borrow::Cow;
use std::io::{self, Write};
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use itertools::Itertools;
use tracing::instrument;

use crate::install::builder::Trigger;
use crate::install::init::{Params, SetupError, Steps};
use crate::install::Mode;
use crate::{Schedule, Step};

use super::Error;

struct Service {
    unit: String,
    path: PathBuf,
}

impl Step for Service {
    fn describe(&self, tense: crate::Tense) -> String {
        todo!()
    }

    fn perform(self) -> Result<(), Box<dyn std::error::Error>> {
        let path = self.path;
        write_unit(&path, &self.unit)
            .map_err(|e| Error::Writing { e, path })
            .map_err(Box::new)
            .map_err(Into::into)
    }
}

struct Timer {
    unit: String,
    path: PathBuf,
}

impl Step for Timer {
    fn describe(&self, tense: crate::Tense) -> String {
        todo!()
    }

    fn perform(self) -> Result<(), Box<dyn std::error::Error>> {
        let path = self.path;
        write_unit(&path, &self.unit)
            .map_err(|e| Error::Writing { e, path })
            .map_err(Box::new)
            .map_err(Into::into)
    }
}

struct EnableTimer {
    name: String,
    mode: Mode,
}

impl Step for EnableTimer {
    fn describe(&self, tense: crate::Tense) -> String {
        todo!()
    }

    fn perform(self) -> Result<(), Box<dyn std::error::Error>> {
        let name = self.name + ".timer";
        super::enable(&name, self.mode)
            .map_err(Error::SystemCtl)
            .map_err(Box::new)
            .map_err(Into::into)
    }
}

struct EnableService {
    name: String,
    mode: Mode,
}

impl Step for EnableService {
    fn describe(&self, tense: crate::Tense) -> String {
        todo!()
    }

    fn perform(self) -> Result<(), Box<dyn std::error::Error>> {
        let name = self.name + ".service";
        super::enable(&name, self.mode)
            .map_err(Error::SystemCtl)
            .map_err(Box::new)
            .map_err(Into::into)
    }
}

pub(crate) fn with_timer(
    path_without_extension: PathBuf,
    params: &Params,
    schedule: &Schedule,
) -> Result<Steps, SetupError> {
    let unit = render_service(&params);
    let path = path_without_extension.with_extension("service");
    let create_service = Box::new(Service { unit, path });
    let unit = render_timer(&params, schedule);
    let path = path_without_extension.with_extension("timer");
    let create_timer = Box::new(Timer { unit, path });
    let enable = Box::new(EnableTimer {
        name: params.name.clone(),
        mode: params.mode,
    });

    Ok(vec![create_service, create_timer, enable])
}

pub(crate) fn without_timer(
    path_without_extension: PathBuf,
    params: &Params,
) -> Result<Steps, SetupError> {
    let unit = render_service(&params);
    let path = path_without_extension.with_extension("service");
    let create_service = Box::new(Service { unit, path });

    let enable = Box::new(EnableTimer {
        name: params.name.clone(),
        mode: params.mode,
    });

    Ok(vec![create_service, enable])
}

fn render_service(params: &Params) -> String {
    let Params {
        exe_path,
        working_dir,
        exe_args,
        trigger,
        ..
    } = params;

    let description = params.description();
    let ty = match trigger {
        Trigger::OnSchedule(_) => "oneshot",
        Trigger::OnBoot => "simple",
    };

    let exe_path = exe_path.display();
    let exe_args: String = Itertools::intersperse(
        exe_args
            .iter()
            .map(String::as_str)
            .map(Cow::Borrowed)
            .map(|s| shell_escape::escape(s))
            .map(Cow::into_owned),
        String::from(" "),
    )
    .collect();

    let working_dir_section = working_dir
        .as_ref()
        .map(|d| format!("\n   WorkingDirectory={}", d.display()))
        .unwrap_or_else(String::new);

    let user = params
        .run_as
        .as_ref()
        .map(|user| format!("\n   User={user}"))
        .unwrap_or_else(String::new);

    let comment = autogenerated_comment(params.bin_name);
    format!(
        "{comment}
            [Unit]
            Description={description}
            After=network.target

            [Service]
            Type={ty}{working_dir_section}{user}
            ExecStart={exe_path} {exe_args}

            [Install]
            WantedBy=multi-user.target
            ",
    )
}

fn autogenerated_comment(bin_name: &'static str) -> String {
    use super::{COMMENT_PREAMBLE, COMMENT_SUFFIX};
    format!("{COMMENT_PREAMBLE}{bin_name}{COMMENT_SUFFIX}")
}

fn render_timer(params: &Params, schedule: &Schedule) -> String {
    let description = params.description();
    let on_calander = match schedule {
        Schedule::Daily(time) => {
            format!("*-*-* {}:{}:{}", time.hour(), time.minute(), time.second())
        }
    };

    format!(
        "[Unit]
        Description={description}
        [Timer]
        OnCalendar={on_calander}
        AccuracySec=60
        [Install]
        WantedBy=timers.target
        "
    )
}

#[instrument(skip(unit), ret)]
fn write_unit(path: &Path, unit: &str) -> Result<(), io::Error> {
    let mut f = std::fs::File::create(path)?;
    f.write_all(unit.as_bytes())?;
    let meta = f.metadata()?;
    let mut perm = meta.permissions();
    perm.set_mode(0o664);
    Ok(())
}
