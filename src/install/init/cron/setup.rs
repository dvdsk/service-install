use std::iter;
use std::path::PathBuf;

use itertools::Itertools;

use super::{Params, SetupError, Steps};
use crate::install::builder::Trigger;
use crate::install::init::{autogenerated_comment, EscapedPath};
use crate::install::Rollback;
use crate::{Schedule, Step};

use super::Line;
use super::RollbackImpossible;
use super::{current_crontab, set_crontab};

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Command `crontab -l` failed, stderr:\n\t")]
    ListFailed { stderr: String },
    #[error("Could not get the current crontab: {0}")]
    GetCrontab(super::GetCrontabError),
    #[error("Comment for previous install at the end of the crontab")]
    CrontabCorrupt,
    #[error("Failed to open crontab stdin")]
    StdinClosed,
    #[error("Error while writing to crontab's stdin: {0}")]
    WritingStdin(std::io::Error),
    #[error("Could not wait on output of crontab program, err: {0}")]
    FailedToWait(std::io::Error),
    #[error("Crontab was modified while installation ran, you should manually verify it")]
    CrontabChanged,
    #[error("Could not find an existing install in crontab")]
    NoExistingInstallFound,
}

pub(crate) fn set_up_steps(params: &Params) -> Result<Steps, SetupError> {
    let current = current_crontab().map_err(Error::GetCrontab)?;
    let comment = autogenerated_comment(params.bin_name);
    let mut lines = current.iter();

    let mut to_remove = None;
    loop {
        let Some(line) = lines.next() else { break };
        if line.text.contains(&comment) {
            let rule = lines.next().ok_or(Error::CrontabCorrupt)?;
            to_remove = Some((line.clone(), rule.clone()));
        };
    }

    let mut steps = Vec::new();
    if let Some((comment, rule)) = to_remove {
        steps.push(Box::new(RemovePrevious { comment, rule }) as Box<dyn Step>);
    }

    use Schedule as S;
    use Trigger::{OnBoot, OnSchedule};
    let when = match params.trigger {
        OnSchedule(S::Daily(time)) => format!("{} {} * * *", time.minute(), time.hour()),
        OnBoot => "@reboot".to_owned(),
    };

    let exe_path = params.exe_path.shell_escaped();
    let exe_args: String = Itertools::intersperse(
        params.exe_args.iter().map(String::shell_escaped),
        String::from(" "),
    )
    .collect();
    let set_working_dir = params
        .working_dir
        .as_ref()
        .map(PathBuf::shell_escaped)
        .map(|dir| format!("cd {dir} &&"))
        .unwrap_or_else(String::new);
    let command = format!("{set_working_dir} {exe_path} {exe_args}");
    let rule = format!("{when} {command}");

    steps.push(Box::new(Add { comment, rule }));
    Ok(steps)
}

#[derive(Debug, Clone)]
pub(crate) struct Add {
    pub(crate) comment: String,
    pub(crate) rule: String,
}

impl Step for Add {
    fn describe(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Appended",
            crate::Tense::Present => "Appending",
            crate::Tense::Future => "Will append",
        };
        format!("{verb} comment and rule to crontab")
    }

    fn describe_detailed(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Appended",
            crate::Tense::Present => "Appending",
            crate::Tense::Future => "Will append",
        };
        let Self { comment, rule } = self;
        let comment = comment.replace("\n", "\n|\t");
        format!("{verb} comment and rule to crontab:\n| comment:\n|\t{comment}\n| rule:\n|\t{rule}")
    }

    fn perform(&mut self) -> Result<Option<Box<dyn Rollback>>, Box<dyn std::error::Error>> {
        let Self { comment, rule } = self.clone();
        let current_crontab = current_crontab()?;
        let new_crontab = current_crontab
            .iter()
            .map(Line::text)
            .chain(iter::once(comment.as_str()))
            .chain(iter::once(rule.as_str()))
            .interleave_shortest(iter::once("\n").cycle())
            .collect();
        set_crontab(new_crontab)?;

        Ok(Some(Box::new(RollbackImpossible)))
    }
}
struct RemovePrevious {
    comment: Line,
    rule: Line,
}
impl Step for RemovePrevious {
    fn describe(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Removed",
            crate::Tense::Present => "Removing",
            crate::Tense::Future => "Will remove",
        };
        format!("{verb} comment and rule from previous installation from crontab")
    }

    fn describe_detailed(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Removed",
            crate::Tense::Present => "Removing",
            crate::Tense::Future => "Will remove",
        };
        let Self { comment, rule } = self;
        format!("{verb} a comment and rule from previous installation from crontab:\n\tcomment: {comment}\n\trule: {rule}")
    }

    fn perform(&mut self) -> Result<Option<Box<dyn Rollback>>, Box<dyn std::error::Error>> {
        let Self { comment, rule } = self;
        let current_crontab = current_crontab()?;

        let mut new_lines = Vec::new();
        for line in &current_crontab {
            for to_remove in [&comment, &rule] {
                if line.text == to_remove.text {
                    if line.pos != to_remove.pos {
                        Err(Error::CrontabChanged)?;
                    } else {
                        continue;
                    }
                }
            }

            new_lines.push(line.text.as_str());
        }

        let new_crontab: String = new_lines
            .into_iter()
            .interleave_shortest(iter::once("\n").cycle())
            .collect();
        set_crontab(new_crontab)?;

        Ok(Some(Box::new(RollbackImpossible)))
    }
}
