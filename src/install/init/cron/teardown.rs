use std::iter;

use itertools::Itertools;

use crate::install::init::{autogenerated_comment, ExeLocation, RSteps, TearDownError};
use crate::install::Mode;
use crate::RemoveStep;

use super::Line;
use super::{current_crontab, set_crontab, GetCrontabError};

mod extract_path;

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Could not get the current crontab: {0}")]
    GetCrontab(#[from] GetCrontabError),
    #[error("Failed to extract the path to the executable from crontab: {0}")]
    NoExistingInstallFound(#[from] extract_path::Error),
    #[error("Comment for previous install at the end of the crontab")]
    CrontabCorrupt,
    #[error("Crontab was modified while uninstall ran, you should manually verify it")]
    CrontabChanged,
}

pub(crate) fn tear_down_steps(
    bin_name: &str,
    mode: Mode,
) -> Result<Option<(RSteps, ExeLocation)>, TearDownError> {
    let current = current_crontab().map_err(Error::GetCrontab)?;
    let landmark_comment = autogenerated_comment(bin_name);

    let to_remove = current
        .windows(landmark_comment.lines().count() + 1)
        .map(|w| w.split_last().expect("window size always >= 2"))
        .find(|(_, comments)| {
            comments
                .into_iter()
                .map(Line::text)
                .eq(landmark_comment.lines())
        });

    let Some((rule, comment)) = to_remove else {
        return Ok(None);
    };

    let install_path =
        extract_path::from_rule(&rule.text).map_err(Error::NoExistingInstallFound)?;
    let step = Box::new(RemoveInstalled {
        comment: comment.to_vec(),
        rule: rule.clone(),
    }) as Box<dyn RemoveStep>;
    Ok(Some((vec![step], install_path)))
}

struct RemoveInstalled {
    comment: Vec<Line>,
    rule: Line,
}

impl RemoveStep for RemoveInstalled {
    fn describe(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Removed",
            crate::Tense::Present => "Removing",
            crate::Tense::Future => "Will remove",
        };
        format!("{verb} comment and rule from installation from crontab")
    }

    fn describe_detailed(&self, tense: crate::Tense) -> String {
        let verb = match tense {
            crate::Tense::Past => "Removed",
            crate::Tense::Present => "Removing",
            crate::Tense::Future => "Will remove",
        };
        let comment: String = self
            .comment
            .iter()
            .map(|Line { pos, text }| format!("|\t{pos}: {text}"))
            .collect();
        let rule = format!("|\t{}: {}", self.rule.pos, self.rule.text);
        format!("{verb} a comment and rule from installation from crontab:\n\tcomment: {comment}\n\trule: {rule}")
    }

    fn perform(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let Self { comment, rule } = self;
        let current_crontab = current_crontab()?;

        let mut new_lines = Vec::new();
        for line in &current_crontab {
            for to_remove in comment.iter().chain(iter::once(&*rule)) {
                if line.text == to_remove.text {
                    if line.pos != to_remove.pos {
                        Err(Error::CrontabChanged)?;
                    } else {
                        continue;
                    }
                }
            }

            new_lines.push(line.text.as_str());
        }

        let new_crontab: String = new_lines
            .into_iter()
            .interleave_shortest(iter::once("\n").cycle())
            .collect();
        set_crontab(new_crontab)?;

        Ok(())
    }
}
